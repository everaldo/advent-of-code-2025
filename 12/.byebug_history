continue
count
exit
sections[0].fit_all_presents?
exit
presents_needed.all?(&:zero?)
presents_needed.all? { |p| p.zero? } 
presents_needed.all?(:zero?)
presents_needed
present_index
continue
is_fit
next
up
s
n
puts present
continue
puts present
present
continue
exit
continue
exit
continue
s
display n
display m
s
display is_fit
s
up
s
display grid[i + m][j + n]
display present[m][n]
s
puts present
present
continue
n
puts present_variation
present_variation
s
n
puts present
n
s
new_section.grid
puts present_variation
present_variation
continue
print j
print i
is_fit
n
up
s
n
up
s
up
s
up
s
display j
display i
display is_fit
s
(height - size)
(width - size)
exit
puts present_variation
present_variation
continue
width
height
present_variation
continue
puts present_variation
continue
puts present_variation
present_variation
continue
help
is_fit
n
display j
display i
grid
height 
height 4
width
puts present
display present
display size
n
up
s
step
fit?(present_variation)
puts(present_variation.to_s)
n
puts(present_variation.to_s)
display puts(present_variation.to_s)
display present_variation.to_s
display present_variation
s
n
s
new_section.presents_needed
puts new_section
new_section
exit
result =  sections[0].fit?(presents[4])
result =  sections[0].fit_all_presents?
puts sections[0]
sections[0]
sections[0].fit_all_presents?
exit
present.id
present
display index
n
up
s
display present[m][n]
s
print(n)
print n
print m
print j
print i
display new_grid[i + m][j + n]
s
display n
display m
n
s
n
s
@grid
display new_grid
display size
s
up
s
display present
coords
s
coords
up
s
variations.size
s
display variations
up
s
puts present
s
presents
n
s
presents_needed
s
display present_index
s
presents_needed
exit
sections[0].fit_all_presents?
sections[0].fit?(presents[4])
exit
sections[0]
exit
[].empty?
sections[0].fit?(presents[4])
exit
sections[0].fit?(presents[4])
sections[0].fit?(present[4])
sections[0]
exit
puts sections[0]
exit
puts sections[0]
sections[0]
exit
Array.new(sections[0][:width]).map { |i| Array.new(sections[0][:height], false)  } 
Array.new(4, false)
Array.new(4, "a")
Array.new(4)
Array.new(sections[0][:width]).map { |i| Array.new(sections[0][:height])  } 
Array.new(sections[0][:width]).map { |i| Array.new(i)  } 
sections[0][:width].map { |i| Array.new(i)  } 
sections[0]
Array([4])
Array(4)
Array.new(4)
sections
puts presents[5]
puts presents[0]
presents[0]
presents
exit
sections
exit
sections
presents
exit
match_data = input =~ regexp
regexp = /\A(?<presents>.*)+(<?regions>\dx\d\:.*)+\z/
match_data = input =~ regexp
regexp = /\A(?<presents>)+(<?regions>\dx\d\:.*)+\z/
match_data = input =~ regexp
input
exit
input.size
input
input.class
match_dat = input =~ regexp
match_dat = input ~= regexp
exit
shape.transpose
shape
