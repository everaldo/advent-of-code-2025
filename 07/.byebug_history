exit
count
exit
@cache
exit
count
exit
count
n
display path
display line_number
display beam
display diagram
s
exit
count
exit
find_timelines(diagram[1..-1], left_path, timelines, map_left, line_number + 1, path + [left_path]).size
find_timelines(diagram[1..-1], left_path, timelines, map_left, line_number + 1, path + [left_path])
path
exit
path
timelines
exit
@cache
continue
left_hash
continue
left_hash
continue
left_hash
continue
left_hash
continue
left_hash
exit
@cache[left_hash]
continue
find_timelines(diagram[1..-1], left_path, timelines, map_left, line_number + 1, path + [left_path])
@cache[left_hash]
beam
left_hash
continue
exit
count
exit
continue
exit
@cache.instance_variable_get(:@cache).keys.uniq.count
@cache.instance_variable_get(:@cache).keys.uniq
@cache.instance_variable_get(:@cache).keys.count
@cache.instance_variable_get(:@cache).keys
@cache.instance_variable_get(:@cache)
@cache.instance_variable_get(:cache)
@cache.public_methods
@cache.public_method(true)
@cache.public_method()
@cache.public_method
@cache
exit
continue
@cache
key
exit
continue
path
path.size
continue
path.size
path
exit
path.size
path
@cache
exit
beam
path.size
path
exit
path.size
path
exit
continue
exit
@cache.class
@cache
continue
count
exit
[1, 2].join
@cache.keys.first
@cache.keys.map(&:size)
@cache.keys.count
@cache.keys
@cache
exit
h
breakpoint
breakpoints
continue
disable breakpoints
disable
h
i
continue
exit
continue
exit
@cache.has_key?(first_key.to_s)
@cache[first_key.to_s] = "ALo"
@cache[first_key.to_s]
@cache[@cache.keys.first]
@cache.has_key?(first_key)
@cache[first_key]
first_key = @cache.keys.first
@cache[first_key]
first_key = @cache.keys.first
@cache[path.append(beam)]
path.append(beam)
info line
i
path.append(left_path)
path
@cache.keys.count
@cache
exit
@cache.keys.first
@cache.keys.count
@cache.keys
@cache
exit
@cache.keys.first
@cache[0]
@cache.keys.count
@cache.keys
@cache
exit
continue
exit
[].empty?
[].nil?
diagram
continue
diagram
continue
exit
puts_map(new_map)
n
line_number
n
new_timelines
puts_map(map)
n
puts_map(map)
n
print has_split
n
display splitters
diagram
puts_map(map)
n
puts_map(new_map)
new_map[line_number]
line_number
print(i)
puts_map(new_map)
n
puts_map(new_map)
n
continue
puts_map(new_map)
n
puts_map(new_map)
continue
puts_map(new_map)
n
puts_map(new_map)
new_map
beam
new_map[line_number + i]
n
print(i)
i
line_number
beam
puts_map(map)
map
exit
puts_map(map)
map
line_number
beam
exit
beam
map.map { |m| puts m.join }
map.map { |m| puts m }
map.join("\n")
map
exit
map_left
continue
exit
new_map[line_number + i][beam]
n
BEAM
new_map[line_number + i][beam]
new_map[line_number + i]
display new_map
beam
print(i)
i
line_number
new_map
map
continue
exit
map_right
map_left
continue
exit
map_left
continue
exit
map_right
map_left
n
continue
display splitters
continue
exit
map_right
map_left
n
s
n
display splitters
continue
exit
map_right
map_left
n
s
splitters
continue
splitters
continue
splitters
continue
exit
print(i)
i
map_left
n
map_left
n
display splitters
